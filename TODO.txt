次に、色を変えられるようにする。
次に、重さを変えられるようにする。
この二つはボタンで実装できると思うんだけど今のボタンをそのまま流用するのは難しそう。
なので、今のボタンの仕様を見直して再利用しやすくしてから取り掛かることとしたい。
それか、モード・・クラス名がモードボタンだからなー。新しく作っちゃった方が速いかな。
もしくはボタンのベースクラスの継承にするとか。で、テキスト書く場合はsuperで呼び出してから追加する、と。色とかあれして・・んー。
重さは5x2くらいにして1.0, 1.2, 1.4, 1.6, 1.8, 2.0, 2.5, 3.0, 3.5, 4.0とかする（？？）
色は9種類でnoTextにする。
ボタンの縁取り、最初にblを0.4倍して塗りつぶしてから0.7倍で横縮めて縦縮めて書いてそれから中央に通常でってやってみたい。なんかうにゃってなるやつ。
で、周囲はちょっと丸くする感じで。

1.ボタンの再利用性を高めるリファクタリング
  ColorButton生成するときに直接色を渡す（パレット使っちゃダメ）
  ボタンは常に一つだけの場合や複数のボタンが同時についたり消えたりする場合があるからそういうのに対応したい
  他にも押してる間だけアクティブとかも面白そうだわね（やらないけど）
  今、普通にどのボタンがアクティブなのかのidを返すようになってるけど一般的じゃないね。
  まずボタンのactivateのタイプは2種類でいいよね（めんどくさい）
  1.マウスダウンされるとactiveになる。逆はない。
  2.マウスダウンされるたびにactive状態が切り替わる。
  これらは混在が許されるのでボタン側にオプションをつけて処理した方がいいと思う。
  次に、ButtonSetの性質として、両立を許すか許さないかってのをつける（unique=true/false）。
  uniqueがtrueである場合、initialize処理で0番をactivateする、どれかがactiveになったらbreakして他をすべてinActivateするっていうのを。やると。
  処理が全然違うので継承で書いた方がいいかも。
  initialize処理は個別に書き換えるのアリだと思う。そこは上書きすればいいんじゃない・・
  めんどうだな。いいよ、普通にactivateで。
  ButtonSetのuniqueとButtonのflipflopっていうプロパティを作ればいいよね。
  if(this.flipflop){
    this.active = !this.active;
  }else{
    this.active = true;
  }
  id返すところをactive状態をあらわす配列を返すようにしたいんだよね。
  id返った方が便利だからやっぱ継承で書きたい・・配列からいちいちactiveなボタンのindex探すのアホみたいでしょ。
  UniqueButtonSet, MultiButtonSet.
  どっちもいじるのおかしいんだな・・。よく考えたら。
  ButtonSetに個性を持たせるならButtonの方はいじらなくていいわな。

  すべきこと：
  ButtonSetを、uniqueとmultiの継承作る
  ColorButtonで色を直接渡すようにする。
  以上。


2.パーティクルの再利用性を高めるリファクタリング
  今のままだと全方位にランダムになってるから
  特定の範囲にだけ出せるようにしようかなって思っただけ。
  さらにぶつかったときにも5つのパーティクルを出すようにしたい。大きさは半分、寿命も半分でいいので。
  寿命半分にしたら地味になったのでサイズだけ半分にしました。

パーティクルをフラッピーでも出したいね。あと、ボタンについて、円形とか作れないかなとか思ったり・・
ああそうだ、hopさせたいんだった。ぽーんって出る感じの。そうしよかな。んー。
てかlifeFactorとかさ、あれ、Systemのプロパティ変更のチェーンメソッドで書いた方がすっきりするでしょ？そうしたいなぁ。
lifeFactorのsetでreturn this.
sizeFactorのsetでreturn this.
hopのsetでreturn this. hopだとparticleがhop状態で生成する。hopだと到達距離の1/4を最高点とする弓なりの軌道を描く？


3.このコードは関係ないけどスライダーも自由に使えるようにしたいわね → え？使うよ？？？

// 今日の仕様変更は3つです。
// 0:パーティクルにhopプロパティを設けて飛び出すときのモーションのチェンジをね・・
// パーティクルセットの方ではもうそれあれしてあるからあとはパーティクルの方をいじるだけ。
// 1:スライダーで大きさを調整できるようにする。コンストラクタは変えない。サイズ調整のメソッドを付け加えて生成した後外部から大きさをいじる。
// それによりsystem側でセットするサイズのファクターが1.0から2.5まで動くからそれに応じてaddBallCheckとaddBallをいじると。これでいける。
// 2:ボタンの形状に円を追加したい。これは、wとかhを渡してるところを{type:"square", left:100, top:50, w:200, h:100}みたいにする。
// 円の方は{type:"circle", cx:100, cy:120, r:50}とかすればいいんじゃない。あとはhitをいじるだけ。
// 要はColliderをいじるってことで。

// ところでスライダーがないんですが・・('ω'乂)ﾀﾞﾒｰ

// カーソル部分とスライダーの太さと始点のベクトルと終点のベクトルと最小値と最大値があればスライダーになる。
// あとはマウスダウンによってアクティベートされてマウス位置が変化したらカーソルも動くようにするだけ。
// マウスダウンの時に(mouseX, mouseY)が登録されてアクティブになってる間はその値とリアルタイムでの(mouseX, mouseY)の値に対して
// そこに向かうベクトルがあるでしょ、それと方向ベクトルの射影を取ってそれがプラスとかマイナスとかを計算してスライダーの位置に
// 反映させれば斜めであっても大丈夫。また円形スライダーも実装できる、これは中心からの方向を反映させるだけだから楽ね。
// ああそうか面倒なことしなくても垂線下ろせばいいのか（そりゃそうでしょ）。
// 垂線おろして、それで反映させる感じね。あと値の取得は個別にメソッド用意すると。

// 3:パーティクル、画像を回転させて描画した方がいいのかどうか検討中。
